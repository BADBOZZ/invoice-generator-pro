## Security Overview

Invoice Generator Pro now ships with a hardened Express API skeleton that can be extended safely. The stack focuses on OWASP Top 10 coverage, abuse prevention, and operational guidance so future features inherit secure defaults.

### Implemented Controls
- **Strict security headers** via Helmet: CSP (self-only scripts/styles), HSTS (1 year, preload), Referrer-Policy `no-referrer`, frame busting, COOP/COEP.
- **Network surface defense**: CORS allow-list enforced through `ALLOWED_ORIGINS` with explicit rejections and TLS-friendly defaults.
- **Abuse protection**: IP-based rate limiting on every `/api/*` route (`RATE_LIMIT_WINDOW_MS`, `RATE_LIMIT_MAX`), HTTP parameter pollution defense (HPP), and 10 kb JSON body limits.
- **Authentication middleware**: Mandatory `x-api-key` header validated by constant-time SHA-256 hash comparison. Missing keys abort startup to avoid unsecured deployments.
- **Input validation**: Zod schemas for mutation and path parameters ensure well-formed invoices and UUID identifiers before they reach business logic.
- **Centralized error handling**: Unified handler prevents stack traces from leaking and always returns a request identifier for correlation.
- **Structured observability**: Request IDs, trust-proxy support, and contextual logging (Morgan) support log aggregation and anomaly detection.

### Threat Model Snapshot
- **Assets**: Invoice data, authentication secrets, financial metadata, operational metrics.
- **Actors**:
  - Legitimate operators (expects 2xx).
  - External attackers (attempting injection, brute force, data exfiltration).
  - Compromised/rogue clients (abuse of API keys, replay attacks).
- **Entry Points**:
  - `/api/v1/invoices` (POST/GET) guarded by API key + validation + rate limits.
  - `/health` (no auth) exposes only liveness metadata.
- **Trust Assumptions**:
  - Traffic terminates at TLS proxy that forwards correct `x-forwarded-*` headers.
  - Operators manage API keys externally (Secrets Manager, Vault, etc).
  - Downstream persistence layer will implement per-tenant access control.

### Environment Hardening

| Variable | Purpose | Notes |
| --- | --- | --- |
| `PORT` | Listener port | Default 4000. |
| `ALLOWED_ORIGINS` | Comma-separated origins allowed by CORS | Leave empty only for highly trusted private networks. |
| `INTERNAL_API_KEY` / `INTERNAL_API_KEY_HASH` | Shared secret protecting all API routes | Supply the hash in production to avoid storing plaintext. |
| `RATE_LIMIT_WINDOW_MS` | Rate-limit window in ms | Default 900000 (15 min). |
| `RATE_LIMIT_MAX` | Requests per window per IP | Default 100. Tighten for sensitive endpoints. |
| `JSON_BODY_LIMIT` | Max payload size | Default 10 kb to mitigate resource exhaustion. |
| `TRUST_PROXY` | Enables Express proxy awareness | Required when behind load balancers/CDNs. |

### Operational Guidance
1. `cp .env.example .env` and replace placeholders with secrets from a managed vault.
2. Provision per-environment API keys; rotate by publishing new hashes and revoking old secrets server-side.
3. Terminate TLS at the edge (CloudFront, Nginx, etc.) and forward `X-Forwarded-For` to preserve client IPs for rate limiting.
4. Ship logs to a SIEM (Datadog, Splunk) filtered by `requestId` for forensic traceability.
5. Add authentication/authorization (JWT/OAuth, RBAC) before exposing customer data externally.

### Residual Risks & Next Steps
- Persistence/auth layers are placeholders. Integrate with PostgreSQL/Prisma using parameterized queries and row-level security before storing data.
- Add structured security logging (JSON) and anomaly alerts (429 spikes, auth failures).
- Introduce automated dependency scanning (npm audit, Snyk) in CI.
- Expand schema validation to every new endpoint and add celebratory integration tests to prevent regressions.
- Model secrets rotation workflow and ensure API keys adopt least privilege (per-client scopes).

